From 9a44e6ff7c7a086a2b72609854f6d914b548c6e5 Mon Sep 17 00:00:00 2001
From: Jianxiong Pan <jianxiong.pan@amlogic.com>
Date: Tue, 20 Jun 2023 19:32:11 +0800
Subject: [PATCH] mm: add memory optimization. [1/1]

PD#SWPL-128561

Problem:
add memory optimization.

Solution:
add memory optimization.

Verify:
local.

Change-Id: I28b07555f88ce0c395edd384d7664217f6ddc329
Signed-off-by: Jianxiong Pan <jianxiong.pan@amlogic.com>
---
 drivers/of/base.c              |  5 ++++-
 include/linux/android_kabi.h   |  5 ++++-
 include/linux/android_vendor.h | 10 ++++++++++
 include/linux/printk.h         |  4 ++++
 include/linux/scs.h            |  4 ++++
 init/init_task.c               |  2 ++
 kernel/Makefile                |  2 ++
 kernel/fork.c                  |  2 ++
 kernel/scs.c                   | 17 +++++++++++++++++
 mm/slab_common.c               |  4 ++++
 10 files changed, 53 insertions(+), 2 deletions(-)

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 7c617b497356..14b584f6f32c 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -166,8 +166,9 @@ void __of_phandle_cache_inv_entry(phandle handle)
 
 void __init of_core_init(void)
 {
+#ifndef CONFIG_AMLOGIC_MEMORY_OPT
 	struct device_node *np;
-
+#endif
 
 	/* Create the kset, and register existing nodes */
 	mutex_lock(&of_mutex);
@@ -177,11 +178,13 @@ void __init of_core_init(void)
 		pr_err("failed to register existing nodes\n");
 		return;
 	}
+#ifndef CONFIG_AMLOGIC_MEMORY_OPT
 	for_each_of_allnodes(np) {
 		__of_attach_node_sysfs(np);
 		if (np->phandle && !phandle_cache[of_phandle_cache_hash(np->phandle)])
 			phandle_cache[of_phandle_cache_hash(np->phandle)] = np;
 	}
+#endif
 	mutex_unlock(&of_mutex);
 
 	/* Symlink in /proc as required by userspace ABI */
diff --git a/include/linux/android_kabi.h b/include/linux/android_kabi.h
index f6dd7f00b386..ee6b29e8d796 100644
--- a/include/linux/android_kabi.h
+++ b/include/linux/android_kabi.h
@@ -83,12 +83,15 @@
  *   number: the "number" of the padding variable in the structure.  Start with
  *   1 and go up.
  */
+#ifdef CONFIG_AMLOGIC_MEMORY_OPT
+#define ANDROID_KABI_RESERVE(number)
+#else
 #ifdef CONFIG_ANDROID_KABI_RESERVE
 #define ANDROID_KABI_RESERVE(number)	_ANDROID_KABI_RESERVE(number)
 #else
 #define ANDROID_KABI_RESERVE(number)
 #endif
-
+#endif /* CONFIG_AMLOGIC_OPT */
 
 /*
  * Macros to use _after_ the ABI is frozen
diff --git a/include/linux/android_vendor.h b/include/linux/android_vendor.h
index af3014ccc82e..f5bce42c8d0d 100644
--- a/include/linux/android_vendor.h
+++ b/include/linux/android_vendor.h
@@ -26,6 +26,15 @@
  *   Same as ANDROID_VENDOR_DATA but allocates an array of u64 with
  *   the specified size
  */
+#ifdef CONFIG_AMLOGIC_MEMORY_OPT
+#define ANDROID_VENDOR_DATA(n)
+#define ANDROID_VENDOR_DATA_ARRAY(n, s)
+#define ANDROID_OEM_DATA(n)
+#define ANDROID_OEM_DATA_ARRAY(n, s)
+
+#define android_init_vendor_data(p, n)
+#define android_init_oem_data(p, n)
+#else
 #ifdef CONFIG_ANDROID_VENDOR_OEM_DATA
 #define ANDROID_VENDOR_DATA(n)		u64 android_vendor_data##n
 #define ANDROID_VENDOR_DATA_ARRAY(n, s)	u64 android_vendor_data##n[s]
@@ -46,5 +55,6 @@
 #define android_init_vendor_data(p, n)
 #define android_init_oem_data(p, n)
 #endif
+#endif
 
 #endif /* _ANDROID_VENDOR_H */
diff --git a/include/linux/printk.h b/include/linux/printk.h
index 9497f6b98339..83e8cfd192e8 100644
--- a/include/linux/printk.h
+++ b/include/linux/printk.h
@@ -336,6 +336,10 @@ extern int kptr_restrict;
  * would prefix all pr_info, pr_emerg... messages in the file with the module
  * name.
  */
+#ifdef CONFIG_AMLOGIC_MEMORY_OPT
+#undef pr_fmt
+#endif
+
 #ifndef pr_fmt
 #define pr_fmt(fmt) fmt
 #endif
diff --git a/include/linux/scs.h b/include/linux/scs.h
index 4ab5bdc898cf..3bd8f1c3019c 100644
--- a/include/linux/scs.h
+++ b/include/linux/scs.h
@@ -16,7 +16,11 @@
 #ifdef CONFIG_SHADOW_CALL_STACK
 
 #define SCS_ORDER		0
+#ifdef CONFIG_AMLOGIC_MEMORY_OPT
+#define SCS_SIZE		(SZ_2K)
+#else
 #define SCS_SIZE		(PAGE_SIZE << SCS_ORDER)
+#endif
 #define GFP_SCS			(GFP_KERNEL | __GFP_ZERO)
 
 /* An illegal pointer value to mark the end of the shadow stack. */
diff --git a/init/init_task.c b/init/init_task.c
index 559eff84a620..dfe427268949 100644
--- a/init/init_task.c
+++ b/init/init_task.c
@@ -214,10 +214,12 @@ struct task_struct init_task
 #ifdef CONFIG_SECCOMP_FILTER
 	.seccomp	= { .filter_count = ATOMIC_INIT(0) },
 #endif
+#ifndef CONFIG_AMLOGIC_MEMORY_OPT
 #ifdef CONFIG_ANDROID_VENDOR_OEM_DATA
 	.android_vendor_data1 = {0, },
 	.android_oem_data1 = {0, },
 #endif
+#endif
 };
 EXPORT_SYMBOL(init_task);
 
diff --git a/kernel/Makefile b/kernel/Makefile
index 2e0dac3da346..821d003cd236 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -81,7 +81,9 @@ obj-$(CONFIG_UTS_NS) += utsname.o
 obj-$(CONFIG_USER_NS) += user_namespace.o
 obj-$(CONFIG_PID_NS) += pid_namespace.o
 obj-$(CONFIG_IKCONFIG) += configs.o
+ifndef CONFIG_AMLOGIC_MEMORY_OPT
 obj-$(CONFIG_IKHEADERS) += kheaders.o
+endif
 obj-$(CONFIG_SMP) += stop_machine.o
 obj-$(CONFIG_KPROBES_SANITY_TEST) += test_kprobes.o
 obj-$(CONFIG_AUDIT) += audit.o auditfilter.o
diff --git a/kernel/fork.c b/kernel/fork.c
index d8b26077824c..993e24f06f1d 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -1045,9 +1045,11 @@ static struct task_struct *dup_task_struct(struct task_struct *orig, int node)
 #ifdef CONFIG_MEMCG
 	tsk->active_memcg = NULL;
 #endif
+#ifndef CONFIG_AMLOGIC_MEMORY_OPT
 #ifdef CONFIG_ANDROID_VENDOR_OEM_DATA
 	memset(&tsk->android_vendor_data1, 0, sizeof(tsk->android_vendor_data1));
 	memset(&tsk->android_oem_data1, 0, sizeof(tsk->android_oem_data1));
+#endif
 #endif
 	trace_android_vh_dup_task_struct(tsk, orig);
 	return tsk;
diff --git a/kernel/scs.c b/kernel/scs.c
index d7809affe740..aa4135c3c43e 100644
--- a/kernel/scs.c
+++ b/kernel/scs.c
@@ -11,6 +11,9 @@
 #include <linux/scs.h>
 #include <linux/vmalloc.h>
 #include <linux/vmstat.h>
+#ifdef CONFIG_AMLOGIC_MEMORY_OPT
+#include <linux/slab.h>
+#endif
 
 #ifdef CONFIG_DYNAMIC_SCS
 DEFINE_STATIC_KEY_FALSE(dynamic_scs_enabled);
@@ -36,16 +39,22 @@ static void *__scs_alloc(int node)
 	for (i = 0; i < NR_CACHED_SCS; i++) {
 		s = this_cpu_xchg(scs_cache[i], NULL);
 		if (s) {
+		#ifndef CONFIG_AMLOGIC_MEMORY_OPT
 			s = kasan_unpoison_vmalloc(s, SCS_SIZE,
 						   KASAN_VMALLOC_PROT_NORMAL);
+		#endif
 			memset(s, 0, SCS_SIZE);
 			goto out;
 		}
 	}
 
+#ifdef CONFIG_AMLOGIC_MEMORY_OPT
+	s = kmalloc(SCS_SIZE, GFP_SCS);
+#else
 	s = __vmalloc_node_range(SCS_SIZE, 1, VMALLOC_START, VMALLOC_END,
 				    GFP_SCS, PAGE_KERNEL, 0, node,
 				    __builtin_return_address(0));
+#endif
 
 out:
 	return kasan_reset_tag(s);
@@ -86,8 +95,12 @@ void scs_free(void *s)
 		if (this_cpu_cmpxchg(scs_cache[i], 0, s) == NULL)
 			return;
 
+#ifdef CONFIG_AMLOGIC_MEMORY_OPT
+	kfree(s);
+#else
 	kasan_unpoison_vmalloc(s, SCS_SIZE, KASAN_VMALLOC_PROT_NORMAL);
 	vfree_atomic(s);
+#endif
 }
 
 static int scs_cleanup(unsigned int cpu)
@@ -96,7 +109,11 @@ static int scs_cleanup(unsigned int cpu)
 	void **cache = per_cpu_ptr(scs_cache, cpu);
 
 	for (i = 0; i < NR_CACHED_SCS; i++) {
+	#ifdef CONFIG_AMLOGIC_MEMORY_OPT
+		kfree(cache[i]);
+	#else
 		vfree(cache[i]);
+	#endif
 		cache[i] = NULL;
 	}
 
diff --git a/mm/slab_common.c b/mm/slab_common.c
index 9fad291c443c..2d727cb4c5c3 100644
--- a/mm/slab_common.c
+++ b/mm/slab_common.c
@@ -67,7 +67,11 @@ static DECLARE_WORK(slab_caches_to_rcu_destroy_work,
 /*
  * Merge control. If this is set then no merging of slab caches will occur.
  */
+#ifdef CONFIG_AMLOGIC_MEMORY_OPT
+static bool slab_nomerge = true;
+#else
 static bool slab_nomerge = !IS_ENABLED(CONFIG_SLAB_MERGE_DEFAULT);
+#endif
 
 static int __init setup_slab_nomerge(char *str)
 {
-- 
2.42.0

